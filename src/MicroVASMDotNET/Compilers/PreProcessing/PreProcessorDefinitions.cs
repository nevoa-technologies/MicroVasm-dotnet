using MicroVASMDotNET.Compilers.Specifications;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Text;

namespace MicroVASMDotNET.Compilers.PreProcessing
{
    public class PreProcessorDefinitions : IPreProcessor, IPreProcessor<ISpecTypes>
    {
        private Dictionary<int, ScopeInfo> scopes = new Dictionary<int, ScopeInfo>();

        private Stack<ScopeInfo> scopesStack = new Stack<ScopeInfo>();
        private Dictionary<int, ScopeInfo> lineScopes = new Dictionary<int, ScopeInfo>();


        // <line of the reference, index in the generated bytecode>
        private Dictionary<long, UInt32> compiledReferences = new Dictionary<long, UInt32>();

        Dictionary<ScopeInfo, Stack<ScopeInfo>> scopeCallTrees = new Dictionary<ScopeInfo, Stack<ScopeInfo>>();

        private Dictionary<string, ScopeInfo> ScopesMap = new Dictionary<string, ScopeInfo>();

        protected byte OPcodeSCOPE => 13;
        protected byte OPcodeEND => 14;

        ScopeInfo rootScope;


        public PreProcessorDefinitions()
        {
            rootScope = new ScopeInfo(0);

            scopes.Add(0, rootScope);
            scopesStack.Push(rootScope);

            scopeCallTrees.Add(rootScope, new Stack<ScopeInfo>());
        }


        internal Dictionary<ScopeInfo, Stack<ScopeInfo>> BuildScopeCallTrees()
        {
            Dictionary<ScopeInfo, Stack<ScopeInfo>> newCallTrees = new Dictionary<ScopeInfo, Stack<ScopeInfo>>();

            foreach (var scope in scopeCallTrees)
            {
                var stack = scope.Value;
                var newStack = new Stack<ScopeInfo>();

                foreach (var s in stack)
                {
                    if (ScopesMap.ContainsKey(s.Name))
                        newStack.Push(ScopesMap[s.Name]);
                }

                newCallTrees[scope.Key] = newStack;
            }

            return newCallTrees;
        }


        public int GetDynamicMemoryUsage(out bool freedAll)
        {
            int memory = 0;
            int maxMemory = 0;
            GetScopeMemoryUsage(rootScope, ref maxMemory, ref memory);

            freedAll = memory == 0;
            return maxMemory;
        }


        private void GetScopeMemoryUsage(ScopeInfo scope, ref int maxMemory, ref int memory)
        {
            foreach (var trace in scope.MemoryTrace)
            {
                if (trace.ScopeIn == null)
                {
                    memory += trace.Size;

                    if (memory > maxMemory)
                        maxMemory = memory;
                }
                else
                {
                    ScopeInfo childScope = ScopesMap[trace.ScopeIn];
                    GetScopeMemoryUsage(childScope, ref maxMemory, ref memory);
                }
            }
        }


        public void PreProcessInstruction(ICompiler compiler, VASMInstructionData instruction)
        {
            ISpecTypes types = (ISpecTypes)compiler;

            if (instruction.Instruction == "CALL")
            {
                if (instruction.Parameters.Count >= 1)
                {
                    string functionName = instruction.Parameters[0];
                    scopeCallTrees[scopesStack.Peek()].Push(new ScopeInfo(0) { Name = functionName});
                    scopesStack.Peek().MemoryTrace.Enqueue(new MemoryTrace(functionName));
                }
            }
            else if (instruction.Instruction == "PUSH")
            {
                if (instruction.Parameters.Count >= 2 && types.GetTypeSize(instruction.Parameters[1], out int size, out bool isUnsigned))
                {
                    scopesStack.Peek().MemoryTrace.Enqueue(new MemoryTrace(size));
                }
            }
            else if (instruction.Instruction == "POP")
            {
                if (instruction.Parameters.Count >= 2 && types.GetTypeSize(instruction.Parameters[1], out int size, out bool isUnsigned))
                {
                    scopesStack.Peek().MemoryTrace.Enqueue(new MemoryTrace(-size));
                }
            }
            else if (instruction.Instruction == "SCOPE")
            {
                if (instruction.HasParameters)
                {
                    if (instruction.Parameters.Count > 1)
                    {
                        compiler.ThrowError(instruction, "SCOPE can only have one parameter indicating the name.");
                        return;
                    }

                    if (scopesStack.Count > 1)
                    {
                        compiler.ThrowError(instruction, "SCOPE cannot be defined inside a SCOPE.");
                        return;
                    }

                    if (scopesStack.Peek().HasReference(instruction.Parameters[0]))
                    {
                        compiler.ThrowError(instruction, "SCOPE cannot have an already defined name.");
                    }

                    foreach (ScopeInfo s in scopesStack.Peek().ParentScopes)
                    {
                        if (s.HasReference(instruction.Parameters[0]))
                        {
                            compiler.ThrowError(instruction, "SCOPE cannot have an already defined name.");
                        }
                    }
                }

                ScopeInfo scope = new ScopeInfo(instruction.LineAsIndex);

                if (instruction.Parameters.Count == 1)
                {
                    scope.Name = instruction.Parameters[0];
                    ScopesMap.Add(scope.Name, scope);
                }

                scopesStack.Peek().AddChildScope(scope);
                scope.ParentScopes = scopesStack.ToArray();
                scopesStack.Push(scope);

                scopes[scope.Line] = scope;
                scopeCallTrees.Add(scope, new Stack<ScopeInfo>());
            }
            else if (instruction.Instruction == "END")
            {
                if (scopesStack.Count > 1)
                    scopesStack.Pop();
                else
                    compiler.ThrowError(instruction, "END must be used when a scope is open.");

            }
            else if (instruction.Instruction == "REFERENCE")
            {
                if (instruction.Parameters.Count != 1)
                {
                    compiler.ThrowError(instruction, "REFERENCE must have one parent indicating the name.");
                    return;
                }

                if (scopesStack.Peek().HasReference(instruction.Parameters[0]))
                {
                    compiler.ThrowError(instruction, "REFERENCE cannot have an already defined name.");
                    return;
                }

                foreach (ScopeInfo scope in scopesStack.Peek().ParentScopes)
                {
                    if (scope.HasReference(instruction.Parameters[0]))
                    {
                        compiler.ThrowError(instruction, "REFERENCE cannot have an already defined name.");
                        return;
                    }
                }

                ReferenceInfo reference = new ReferenceInfo(instruction.Parameters[0], instruction.LineAsIndex);
                scopesStack.Peek().AddReference(reference);
            }
            else if (instruction.Instruction == "DEF")
            {
                if (instruction.Parameters.Count < 2)
                {
                    compiler.ThrowError(instruction, "DEF must have at least 2 parameters.");
                    return;
                }

                if (instruction.Parameters.Count > 3)
                {
                    compiler.ThrowError(instruction, "DEF cannot have more than 3 parameters.");
                    return;
                }

                if (scopesStack.Peek().HasDefinition(instruction.Parameters[1]))
                {
                    compiler.ThrowError(instruction, "DEF cannot define an already defined name.");
                    return;
                }

                foreach (ScopeInfo scope in scopesStack.Peek().ParentScopes)
                {
                    if (scope.HasDefinition(instruction.Parameters[1]))
                    {
                        compiler.ThrowError(instruction, "DEF cannot define an already defined name.");
                        return;
                    }
                }

                DefinitionInfo definition = new DefinitionInfo(instruction.Parameters[1]);

                if (types.GetTypeSize(instruction.Parameters[0], out int typeSize, out bool isUnsigned) && types.GetTypeValue(instruction.Parameters[0], out ValueType type))
                {
                    definition.Type = type;
                    definition.Size = typeSize;
                    definition.IsUnsigned = isUnsigned;
                }
                else
                {
                    compiler.ThrowError(instruction, "DEF must have a type or a number in first parameter.");
                    return;
                }

                byte[] bytes = null;
                bool isNegativeInt = false;

                if (instruction.Parameters.Count == 3)
                    bytes = compiler.ParseValue(instruction.Parameters[2], definition.Type, out isNegativeInt);

                if (bytes == null)
                {
                    compiler.ThrowError(instruction, "DEF must have a valid value.");
                    return;
                }

                definition.Value = compiler.FitDataInSize(instruction, bytes, isNegativeInt, definition.IsUnsigned, definition.Size);

                if (scopesStack.Peek().DefinitionsCount > 0)
                    definition.Index = scopesStack.Peek().LastDefinition.Index + scopesStack.Peek().LastDefinition.Size;

                scopesStack.Peek().AddDefinition(definition);
            }

            lineScopes[instruction.LineAsIndex] = scopesStack.Peek();
        }


        public void StartProcessing(ICompiler compiler)
        {

        }


        public bool HasReference(int line, string name, out object data)
        {
            data = -1;

            if (!lineScopes.ContainsKey(line))
                return false;

            ScopeInfo scope = lineScopes[line];

            if (scope.Name == name)
            {
                data = scope.Line;
                return true;
            }

            if (scope.HasReference(name, out long lineOut))
            {
                data = lineOut;
                return true;
            }

            foreach (ScopeInfo s in scope.ParentScopes)
            {
                if (s.HasReference(name, out long lineOut2))
                {
                    data = lineOut2;
                    return true;
                }
            }

            return false;
        }


        public bool HasDefinition(int line, string name)
        {
            if (!lineScopes.ContainsKey(line))
                return false;

            ScopeInfo scope = lineScopes[line];

            if (scope.HasDefinition(name))
            {
                return true;
            }

            foreach (ScopeInfo s in scope.ParentScopes)
            {
                if (s.HasDefinition(name))
                {
                    return true;
                }
            }

            return false;
        }


        public byte[] ProcessInstruction(ICompiler compiler, VASMInstructionData instruction)
        {
            if (instruction.Instruction == "SCOPE")
            {
                compiledReferences.Add(instruction.LineAsIndex, compiler.CurrentBytecodeLength);
                List<byte> result = new List<byte>();
                result.Add(OPcodeSCOPE);

                byte[] scopeMemory = GetScopeMemory(instruction.LineAsIndex);

                if (scopeMemory == null)
                    return null;

                result.AddRange(scopeMemory);

                return result.ToArray();
            }

            if (instruction.Instruction == "END")
                return new byte[] { OPcodeEND };

            if (instruction.Instruction == "DEF")
                return new byte[0];

            if (instruction.Instruction == "REFERENCE")
            {
                compiledReferences.Add(instruction.LineAsIndex, compiler.CurrentBytecodeLength);
                return new byte[0];
            }

            return null;
        }


        public byte[] GetScopeMemory(int scopeLine)
        {
            if (scopes.ContainsKey(scopeLine))
                return scopes[scopeLine].GetDefinitionsValues();

            return null;
        }


        public bool GetReferenceIndex(long line, out UInt32 index)
        {
            index = 0;

            if (!compiledReferences.ContainsKey(line))
                return false;

            index = compiledReferences[line];
            return true;
        }


        public bool GetDefinitionIndex(int line, string name, out Int32 index)
        {
            index = 0;

            if (!HasDefinition(line, name))
                return false;

            ScopeInfo scope = lineScopes[line];

            if (scope.HasDefinition(name))
                index = scope.GetDefinitionStackAddress(name, true);
            else
            {
                foreach (ScopeInfo s in scope.ParentScopes)
                {
                    if (s.HasDefinition(name))
                        index = s.GetDefinitionStackAddress(name, false);
                }
            }

            return true;
        }


        internal class ScopeInfo
        {
            private List<DefinitionInfo> definitions = new List<DefinitionInfo>();
            private List<ReferenceInfo> references = new List<ReferenceInfo>();

            private List<ScopeInfo> childScopes = new List<ScopeInfo>();

            public string Name { get; set; }
            public int Line { get; }
            public ScopeInfo[] ParentScopes { get; set; } = new ScopeInfo[0];

            public Queue<MemoryTrace> MemoryTrace { get; } = new Queue<MemoryTrace>();


            public int ReferencesCount => references.Count;
            public int DefinitionsCount => definitions.Count;
            public DefinitionInfo LastDefinition => (definitions.Count > 0) ? definitions[definitions.Count - 1] : null;


            public ScopeInfo(int line)
            {
                this.Line = line;
            }


            public void AddDefinition(DefinitionInfo definitionInfo)
            {
                definitions.Add(definitionInfo);
            }


            public void AddReference(ReferenceInfo referenceInfo)
            {
                references.Add(referenceInfo);
            }


            public void AddChildScope(ScopeInfo scopeInfo)
            {
                childScopes.Add(scopeInfo);
            }


            public bool HasDefinition(string name)
            {
                foreach (DefinitionInfo definition in definitions)
                    if (definition.Name == name)
                        return true;

                return false;
            }


            public int GetDefinitionStackAddress(string name, bool scopeRelative)
            {
                int endIndex = LastDefinition.Index + LastDefinition.Size;

                foreach (DefinitionInfo definition in definitions)
                    if (definition.Name == name)
                        if (scopeRelative)
                            return -(endIndex - definition.Index);
                        else
                            return definition.Index;

                return 0;
            }


            public bool HasReference(string name)
            {
                foreach (ReferenceInfo reference in references)
                    if (reference.Name == name)
                        return true;

                foreach (ScopeInfo childScope in childScopes)
                    if (childScope.Name == name)
                        return true;

                return Name == name;
            }


            public bool HasReference(string name, out long referenceLine)
            {
                referenceLine = -1;

                foreach (ReferenceInfo reference in references)
                    if (reference.Name == name)
                    {
                        referenceLine = reference.Line;
                        return true;
                    }

                foreach (ScopeInfo childScope in childScopes)
                    if (childScope.Name == name)
                    {
                        referenceLine = childScope.Line;
                        return true;
                    }

                return Name == name;
            }


            public byte[] GetDefinitionsValues()
            {
                List<byte> result = new List<byte>();

                foreach (var def in definitions)
                {
                    result.AddRange(def.Value);
                }

                byte[] countBytes = BitConverter.GetBytes(result.Count).AsLittleEndian();
                result.InsertRange(0, countBytes);

                return result.ToArray();
            }


            public int GetDefinitionsDataSize()
            {
                int size = 0;

                foreach (var def in definitions)
                {
                    size += def.Size;
                }

                return size;
            }
        }


        internal class DefinitionInfo
        {
            public string Name { get; }
            public int Size { get; set; }
            public bool IsUnsigned { get; set; } = true;
            public byte[] Value { get; set; }
            public int Index { get; set; }
            public ValueType Type { get; set; }


            public DefinitionInfo(string name)
            {
                this.Name = name;
            }
        }


        internal class ReferenceInfo
        {
            public string Name { get; }
            public int Line { get; set; }


            public ReferenceInfo(string name, int line)
            {
                this.Name = name;
                this.Line = line;
            }
        }


        internal class MemoryTrace
        {
            // When ScopeIn is null, means the is pushing or popping a value.
            // Otherwise, is entering in a scope.

            public string ScopeIn { get; set; }
            public int Size { get; set; }

            public MemoryTrace(string scopeIn)
            {
                this.ScopeIn = scopeIn;
            }


            public MemoryTrace(int size)
            {
                this.Size = size;
            }
        }
    }
}
